<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="EN">
<!-- ABENVALUE_CONSTRUCTOR_PARAMS_STRUC -->

<!-- Mirrored from help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_struc.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Feb 2024 14:51:36 GMT -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="author" content="SAP">
<meta name="description" content="VALUE - Structures">
<title>
VALUE - Structures - ABAP Keyword Documentation
</title>
<link rel="icon" href="ABAPIcon.ico" type="image/ico">
<link rel="shortcut icon" href="ABAPIcon.ico">
<LINK rel="stylesheet" href="abap_docu.css" type="text/css">
<script language="javascript" type="text/javascript" src="functions.js"></script>
<script type="text/JavaScript">
function urlToClipboard(id){
 try{ var loc = top.location.href;}
 catch(e){ alert( "URL cannnot be determined" ); return; }
 var field = document.getElementById(id);
 field.focus();
 if ( loc.search( ".htm" ) == -1 && loc.search( ".HTM" ) == -1  ){ loc = loc + "index.htm"; }
 if (   loc.search( "index.html" ) != -1
     || loc.search( "INDEX-2.html" ) != -1 ){
   var off = loc.search( "file=" );
   if ( off == -1  ){
     field.value = loc + "?file=abenvalue_constructor_params_struc.htm"; }
   else {
     field.value = loc.substring( 0, off ) + "file=abenvalue_constructor_params_struc.htm";
   }
 }
 else {
    field.value = loc; }
 field.setSelectionRange(0, field.value.length);
 var r = confirm( "Copy URL to clipboard?\n\n" + field.value + "\n\nCopy to clipboard does not work in all browsers." );
 if (r == true) {
   try{
     document.execCommand("copy");
   }
     catch(e){ alert( "URL could not be copied to clipboard" ); }
 }
 window.scrollTo(0,0);
}
</script>
</head>
<body>
<div class="all">
<div style="float:right;">
<input type="button" value="URL"
style="font-size:10px; width:30px; height:18px; padding:0; "
onclick="urlToClipboard('url')" title="Copy URL to Clipboard" ></div>
<p>
<input name="query" id="query" value="" type="text" title="Suchbegriff" size="30" maxlength="30" onkeyup="getInput()">&nbsp;
<input type="button" value="Search"
style="font-size:12px; width:50px; height:18px; padding:0"
onclick="call_search('search.html')" title="Search in ABAP Keyword Documentation" >
<hr style="width:100%;height:1px"></p>
<p class="copyright">AS ABAP Release 754, &copy;Copyright 2019 SAP SE. All rights reserved.</p>
<span class="path">
<a href="javascript:call_link('abenabap.html')" class="blue">ABAP Keyword Documentation</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abenabap_reference.html')" class="blue">ABAP &#x2212; Reference</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abencreate_objects.html')" class="blue">Creating Objects and Values</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abenconstructor_expression_value.html')" class="blue">VALUE - Value Operator</a>&nbsp;&rarr;&nbsp;
</span>
<A NAME="@@BASE@@VALUE struct@@"></A>
<p><span class="h1">
VALUE - Structures
</span></p>
<A name="@@ITOC@@ABENVALUE_CONSTRUCTOR_PARAMS_STRUC_1"></A>
<p><span class="h2">
Syntax
</span></p>
<p>
<span class="qtext">... VALUE dtype<i class=bn>|</i>#( <i class=bn>[</i><a href="javascript:call_link('abaplet.html')" class="blue">let_exp</a><i class=bn>]</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i class=bn>[</i>BASE dobj<i class=bn>]</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comp1 = dobj1 comp2 = dobj2 ... ) ...</span>
</p>
<p><span class="h4">
Effect
</span></p>
<p>
If <span class="qtext">dtype</span> is a structured data type or <span class="qtext">#</span> stands
for a type like this, the individual components can be specified as named arguments <span class="qtext">comp1</span>,
<span class="qtext">comp2</span>, ... Each component of the return value can be assigned a data object
with the same data type as the component (or whose data type can be converted to this data type). This assignment is made for all data types in accordance with the appropriate
<a href="javascript:call_link('abenconversion_rules.html')" class="blue">assignment rules</a>.
</p>
<p>
An addition <span class="qtext">BASE</span> can be specified in front of the individual component assignments, followed by a data object <span class="qtext">dobj</span>. <span class="qtext">dobj</span> is a
<a href="javascript:call_link('abenfunctional_position_glosry.html')" class="grey" title="Glossary Entry">functional operand
position</a>. The type of <span class="qtext">dobj</span> must be convertible to the type of the return
value. If <span class="qtext">BASE</span> is specified, the content of <span class="qtext">dobj</span>
is assigned to the return value before the individual components are assigned. If the character <span class="qtext">
#</span> is specified for the type of the return value and the type cannot be determined from the operand
position of the <span class="qtext">VALUE</span> expression, the type of <span class="qtext">dobj</span> is used for this expression (if known and structured).
</p>
<p>
<span class="qtext">dobj1</span>, <span class="qtext">dobj2</span>, ... are
<a href="javascript:call_link('abengeneral_expr_position_glosry.html')" class="grey" title="Glossary Entry">general expression
positions</a>. An optional <span class="qtext">LET</span> expression <a href="javascript:call_link('abaplet.html')" class="blue"><span class="qtext">
let_exp</span></a> can be specified in front of the assignments to define local helper fields that can be used on the right side of the assignments.
</p>
<p>
If a component is structured itself, either a suitable data object can be assigned to the entire substructure or its components can be specified using the structure component selector
(<span class="qtext">-</span>). Non-specified components are ignored and keep their type-specific initial
value or the value assigned using <span class="qtext">BASE</span>. It is not possible to assign multiple
values to a component, regardless of how the component is addressed. If the addition <span class="qtext">BASE</span> is used, at least one component must be specified.
</p>
<p>
If the <span class="qtext">VALUE</span> operator is used as the source of an assignment to a structure,
this structure is first initialized after any <a href="javascript:call_link('abaplet.html')" class="blue"><span class="qtext">LET</span></a>
expressions are evaluated or the structure is first assigned the data object <span class="qtext">dobj</span>
after <span class="qtext">BASE</span>. The assignments are then executed directly in the parentheses, with the structure components as target fields.
</p>
<p><span class="h4">
Notes
</span></p>
<ul class="disc">
<li>The assignments can be specified in the parentheses after the optional additions <span class="qtext">LET ... IN</span> and <span class="qtext">BASE</span>, in any order.</li>
</ul>
<ul class="disc">
<li>If a component with a complex data type is constructed in an argument position, the value operator
<span class="qtext">VALUE</span> can be used again. Tabular components, for example, are affected by
this. This is also possible for structured components but is not necessary since the subcomponents can be addressed using the structure component selector.</li>
</ul>
<ul class="disc">
<li>The rule that a target structure of an assignment is first overwritten in full and then modified
directly can produce unexpected results if structure components on the left side are specified as data
objects pending assignment on the right side. Instead of the assignments on the right side being evaluated
and assigned first, the current value is used in every assignment. If the entire structure or structure
components from the left side are needed on the right side, however, they can be saved in local helper
variables using a <a href="javascript:call_link('abaplet.html')" class="blue"><span class="qtext">LET</span></a> expression, since this expression is evaluated first.</li>
</ul>
<ul class="disc">
<li>If the target table is specified as <span class="qtext">dobj</span> after <span class="qtext">BASE</span>
in an assignment to an existing structure, no assignment takes place before the component assignments are evaluated, and the target structure just keeps its value instead.</li>
</ul>
<p><span class="h4">
Example
</span></p>
<p>
Three different ways of filling a nested structure <span class="qtext">struct</span> with values. The structure is given the same values each time.
</p>
<p class="qtextml1">
<span class="qtext">
TYPES:&nbsp;&nbsp;BEGIN OF t_col2, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col1 TYPE i, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 TYPE i, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END OF t_col2. <br>
 <br>TYPES: BEGIN OF t_struct, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col1 TYPE i, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 TYPE t_col2, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END OF t_struct. <br> <br>DATA: struct TYPE t_struct, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;col2 TYPE t_col2. <br>
 <br>struct = VALUE t_struct( col1 = 1 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2-col1 = 1 <br>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2-col2 = 2 ). <br>
 <br>col2&nbsp;&nbsp; = VALUE&nbsp;&nbsp; t_col2( col1 = 1 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = 2 ). <br>
struct = VALUE t_struct( col1 = 1 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = col2 ). <br>
 <br>struct = VALUE t_struct( col1 = 1 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = VALUE #( col1 = 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = 2 ) ).
</span>
</p>
<p><span class="h4">
Example
</span></p>
<P>
This example displays the effects produced if components of a target structure are used as assignment
sources. After the assignment to <span class="qtext">struct1</span>, <span class="qtext">col1</span>
and <span class="qtext">col2</span> have the value 0 and <span class="qtext">col3</span> and <span class="qtext">col4</span>
have the value 5. The original values of <span class="qtext">col1</span> and <span class="qtext">col2</span>
are not switched and <span class="qtext">col3</span> is not given the original value of <span class="qtext">col4</span>.
The assignment to <span class="qtext">struct2</span> demonstrates how the behavior can be changed by
saving the target object to a helper variable <span class="qtext">x</span> and using this object. In
<span class="qtext">struct2</span>, the original values of <span class="qtext">col1</span> and <span class="qtext">
col2</span> are switched and <span class="qtext">col3</span> is given the original value of <span class="qtext">col4</span>.
</P>
<p class="qtextml1">
<span class="qtext">
DATA: <br>&nbsp;&nbsp;BEGIN OF struct, <br>&nbsp;&nbsp;&nbsp;&nbsp;col1 TYPE i VALUE 1, <br>&nbsp;&nbsp;&nbsp;&nbsp;col2&nbsp;&nbsp;&nbsp;&nbsp; TYPE i VALUE 2, <br>
&nbsp;&nbsp;&nbsp;&nbsp;col3 TYPE i VALUE 3, <br>&nbsp;&nbsp;&nbsp;&nbsp;col4 TYPE i VALUE 4, <br>&nbsp;&nbsp;END OF struct, <br>
&nbsp;&nbsp;struct1 LIKE struct, <br>&nbsp;&nbsp;struct2 LIKE struct. <br> <br>struct1 = struct2 = struct. <br>
 <br>struct1 = VALUE #( col1 = struct1-col2 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = struct1-col1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col4 = 5 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col3 = struct1-col4 ). <br>
 <br>cl_demo_output=>write( struct1 ). <br> <br>struct2 = VALUE #( LET x = struct2 IN <br>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col1 = x-col2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col2 = x-col1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col4 = 5 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col3 = x-col4 ). <br> <br>cl_demo_output=>display( struct2 ).
</span>
</p>
<p><span class="h4">
Example
</span></p>
<p>
Uses <span class="qtext">BASE</span>. The type of the return value of <span class="qtext">base1</span>
is applied in the construction of <span class="qtext">struct1</span>. This is not possible in the construction
of <span class="qtext">struct2</span>, since <span class="qtext">base2</span> is not structured. In
both results, <span class="qtext">col1</span> and <span class="qtext">col3</span> have the values <span class="qtext400">
xx</span> or <span class="qtext400">zz</span> assigned using <span class="qtext">BASE</span>, whereas <span class="qtext">col2</span> has the directly assigned value <span class="qtext400">BB</span>.
</p>
<p class="qtextml1">
<span class="qtext">
TYPES: <br>&nbsp;&nbsp;BEGIN OF struct, <br>&nbsp;&nbsp;&nbsp;&nbsp;col1 TYPE c LENGTH 2, <br>&nbsp;&nbsp;&nbsp;&nbsp;col2 TYPE c LENGTH 2, <br>
&nbsp;&nbsp;&nbsp;&nbsp;col3 TYPE c LENGTH 2, <br>&nbsp;&nbsp;END OF struct. <br> <br>DATA(base1)&nbsp;&nbsp; = VALUE struct( col1 = 'xx' col2 = 'yy' col3 = 'zz' ). <br>
DATA(struct1) = VALUE #( BASE base1 col2 = 'BB' ). <br> <br>DATA(base2)&nbsp;&nbsp; = `xxyyzz`. <br>DATA(struct2) = VALUE struct( BASE base2 col2 = 'BB' ). <br>
 <br>cl_demo_output=>write(&nbsp;&nbsp; struct1 ). <br>cl_demo_output=>display( struct2 ).
</span>
</p>
<p><span class="h4">
Example
</span></p>
<p>
Uses <span class="qtext">BASE</span> with a <a href="javascript:call_link('abenconstructor_expr_corresponding.html')" class="blue"><span class="qtext">
CORRESPONDING</span> expression</a> for an assignment between two incompatible structures. <span class="qtext">struct1</span>
is first assigned the identically named components of <span class="qtext">struct2</span> and then the
remaining components are filled explicitly. The same can be done for the columns of an internal table
by performing an appropriate assignment within an iteration using <a href="javascript:call_link('abenfor_itab.html')" class="blue"><span class="qtext">FOR</span></a>.
</p>
<p class="qtextml1">
<span class="qtext">
DATA: <br>&nbsp;&nbsp;BEGIN OF struct1, <br>&nbsp;&nbsp;&nbsp;&nbsp;col1 TYPE i, <br>&nbsp;&nbsp;&nbsp;&nbsp;col2 TYPE i, <br>
&nbsp;&nbsp;&nbsp;&nbsp;col3 TYPE i, <br>&nbsp;&nbsp;&nbsp;&nbsp;col4 TYPE i, <br>&nbsp;&nbsp;&nbsp;&nbsp;col5 TYPE i, <br>
&nbsp;&nbsp;END OF struct1, <br>&nbsp;&nbsp;BEGIN OF struct2, <br>&nbsp;&nbsp;&nbsp;&nbsp;col1 TYPE i VALUE 1, <br>
&nbsp;&nbsp;&nbsp;&nbsp;col2 TYPE i VALUE 2, <br>&nbsp;&nbsp;&nbsp;&nbsp;col3 TYPE i VALUE 3, <br>&nbsp;&nbsp;END OF struct2. <br> <br>struct1 = VALUE #( BASE CORRESPONDING #( struct2 ) col4 = 4 col5 = 5 ). <br>
</span>
</p>
<p><span class="h4">
Examples
</span></p>
<p>
See also the examples for the instance operator <a href="javascript:call_link('abennew_constructor_params_struct.html')" class="blue"><span class="qtext">NEW</span></a>.
</p>
<br>
<br>
<br>
<br>
</DIV>
<fieldset style="opacity:0">
<input id="url" type="text" />
</fieldset>
</BODY>

<!-- Mirrored from help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenvalue_constructor_params_struc.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Feb 2024 14:51:36 GMT -->
</html>
