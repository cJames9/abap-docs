<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="EN">
<!-- ABENPROG_INTERN_NAMES_GUIDL -->

<!-- Mirrored from help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprog_intern_names_guidl.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Feb 2024 14:53:05 GMT -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="author" content="SAP">
<meta name="description" content="Program-Internal Names">
<title>
Program-Internal Names - ABAP Keyword Documentation
</title>
<link rel="icon" href="ABAPIcon.ico" type="image/ico">
<link rel="shortcut icon" href="ABAPIcon.ico">
<LINK rel="stylesheet" href="abap_docu.css" type="text/css">
<script language="javascript" type="text/javascript" src="functions.js"></script>
<script type="text/JavaScript">
function urlToClipboard(id){
 try{ var loc = top.location.href;}
 catch(e){ alert( "URL cannnot be determined" ); return; }
 var field = document.getElementById(id);
 field.focus();
 if ( loc.search( ".htm" ) == -1 && loc.search( ".HTM" ) == -1  ){ loc = loc + "index.htm"; }
 if (   loc.search( "index.html" ) != -1
     || loc.search( "INDEX-2.html" ) != -1 ){
   var off = loc.search( "file=" );
   if ( off == -1  ){
     field.value = loc + "?file=abenprog_intern_names_guidl.htm"; }
   else {
     field.value = loc.substring( 0, off ) + "file=abenprog_intern_names_guidl.htm";
   }
 }
 else {
    field.value = loc; }
 field.setSelectionRange(0, field.value.length);
 var r = confirm( "Copy URL to clipboard?\n\n" + field.value + "\n\nCopy to clipboard does not work in all browsers." );
 if (r == true) {
   try{
     document.execCommand("copy");
   }
     catch(e){ alert( "URL could not be copied to clipboard" ); }
 }
 window.scrollTo(0,0);
}
</script>
</head>
<body>
<div class="all">
<div style="float:right;">
<input type="button" value="URL"
style="font-size:10px; width:30px; height:18px; padding:0; "
onclick="urlToClipboard('url')" title="Copy URL to Clipboard" ></div>
<p>
<input name="query" id="query" value="" type="text" title="Suchbegriff" size="30" maxlength="30" onkeyup="getInput()">&nbsp;
<input type="button" value="Search"
style="font-size:12px; width:50px; height:18px; padding:0"
onclick="call_search('search.html')" title="Search in ABAP Keyword Documentation" >
<hr style="width:100%;height:1px"></p>
<p class="copyright">AS ABAP Release 754, &copy;Copyright 2019 SAP SE. All rights reserved.</p>
<span class="path">
<a href="javascript:call_link('abenabap.html')" class="blue">ABAP Keyword Documentation</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abenabap_pgl.html')" class="blue">ABAP Programming Guidelines</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abenstructure_style_guidl.html')" class="blue">Structure and Style</a>&nbsp;&rarr;&nbsp;
<a href="javascript:call_link('abennaming_guidl.html')" class="blue">Naming</a>&nbsp;&rarr;&nbsp;
</span>
<p><span class="h1">
Program-Internal Names
</span></p>
<A name="@@ITOC@@ABENPROG_INTERN_NAMES_GUIDL_1"></A>
<p><span class="h2">
Background
</span></p>
<p>
Program-internal names describe entities that are declared in the program and are called within the
program or called by other programs. Typical examples include identifiers for data types and data objects as well as methods and method interface parameters.
</p>
<p>
Program-internal declarations can be configured in different contexts that all span a separate namespace. These contexts are arranged in the order from local to global:
</p>
<ol>
<li>
Local declarations in a procedure (<a href="javascript:call_link('abenfunct_module_subroutine_guidl.html')" class="lnkpurple" title="Guideline">Method</a>)
</li>
<li>
Declarations of instance components and static components in a class
</li>
<li>
Global declarations in the declaration part of a program
</li>
</ol>
<p>
Here local declarations always obscure the more global declarations of higher contexts. Different types
of declarations each span a separate namespace in their context, except the class components, which are all located in one single namespace, regardless of their type.
</p>
<p>
The identifiers used in ABAP programs are must comply with the syntactic requirements for classes (in accordance with the rule
<a href="javascript:call_link('abenabap_obj_progr_model_guidl.html')" class="lnkpurple" title="Guideline">Use ABAP Objects</a> and the rule
<a href="javascript:call_link('abenprogram_attribute_guidl.html')" class="lnkpurple" title="Guideline">Applying Default Settings
to Program Attributes</a>). In other words, the identifiers must begin with a letter, which is followed other letters and numbers that can be separated by underscores.
</p>
<A name="@@ITOC@@ABENPROG_INTERN_NAMES_GUIDL_2"></A>
<p><span class="h2">
Rule
</span></p>
<p>
<span class="bold">Prevent program-internal names from being confused or obscured</span>
</p>
<p>
Choose program-internal names that cannot be confused with ABAP words or other declarations. In addition,
a local name must not obscure a more global name. Global entities and interface parameters of procedures should have a prefix for identification purposes.
</p>
<A name="@@ITOC@@ABENPROG_INTERN_NAMES_GUIDL_3"></A>
<p><span class="h2">
Details
</span></p>
<p>
Besides using the general rule of assigning <a href="javascript:call_link('abentelling_names_guidl.html')" class="lnkpurple" title="Guideline">
meaningful names</a>, it is also important for program-internal declarations that you stick to the above
rule of eliminating human error (avoiding name confusion). Unlike a human reader, the compiler usually
knows exactly what an identifier is referring to. Use the following prefixes to avoid the danger of unwanted obscuring and name confusion:
</p>
<ul class="disc">
<li><span class="qtext">g_</span> for global data objects</li>
</ul>
<ul class="disc">
<li><span class="qtext">l_</span> for local data objects that obscure static attributes</li>
</ul>
<ul class="disc">
<li><span class="qtext">i_</span> for <span class="qtext">IMPORTING</span> parameters</li>
</ul>
<ul class="disc">
<li><span class="qtext">e_</span> for <span class="qtext">EXPORTING</span> parameters</li>
</ul>
<ul class="disc">
<li><span class="qtext">c_</span> for <span class="qtext">CHANGING</span> parameters</li>
</ul>
<ul class="disc">
<li><span class="qtext">r_</span> for <span class="qtext">RETURNING</span> parameters</li>
</ul>
<p>
You can also use compound identifiers and component selectors.
</p>
<p>
The following sections discuss the different aspects of program-internal names in detail and with a systematic approach.
</p>
<p><span class="h4">
Confusion with ABAP Words
</span></p>
<p>
A basic rule in almost all naming specifications is that language statements must not be used as names
in the source code (assuming that this is permitted by the syntax). The aim of this measure is to improve
readability by preventing confusion between statements and names. In ABAP, however, it is difficult
to strictly adhere to this rule, because the vocabulary of the programming language is very extensive
and is continuously growing. In most cases, developers will not have memorized all the ABAP words that
occur in all the statements and statement additions. Also, they cannot possibly know which words will be added in future.
</p>
<p>
For this reason, it is not logical or feasible to completely prohibit the use of ABAP words (ABAP keywords
or additions) as names. Thanks to the color highlighting in ABAP Editor and the different capitalization rules in operands and ABAP words
(<a href="javascript:call_link('abenuse_pretty_printer_guidl.html')" class="lnkpurple" title="Guideline">Pretty Printer</a>),
there is no risk of confusion. If in doubt, you can always use the (!) character directly in front of a name, to distinguish it from an ABAP word with the same name in a statement.
</p>
<p>
A single ABAP word, however, usually does not represent a descriptive name. Therefore, we recommend that you only use ABAP words as part of combined names with underscores
(<span class="qtext">_</span>), for instance, <span class="qtext">account_class</span> instead of <span class="qtext">
class</span>. Because the underscore is not used in most ABAP words, it is usually a good idea to distinguish between ABAP words and
<a href="javascript:call_link('abentelling_names_guidl.html')" class="lnkpurple" title="Guideline">names</a>. In some very rare
cases, the compiler cannot distinguish an ABAP word from a name that is identical to the word. In these cases, the escape character (!) must be specified.
</p>
<p><span class="h4">
Confusion between different declarations
</span></p>
<p>
In classes, all components are in the same namespace. Therefore, it is not possible to have data types and attributes with the same name within a class to avoid confusion.  In the other contexts, that is, within procedures
(<a href="javascript:call_link('abenfunct_module_subroutine_guidl.html')" class="lnkpurple" title="Guideline">Methods</a>), or
for global declarations of an ABAP program, different declarations generate different namespaces. Here
it is possible to have data objects and data types with the same name. Object types (local classes and interfaces) are in the same namespace as data types.
</p>
<p>
To avoid confusion, we recommend that you use different names for different entities, and that you do
not use the same names for data types and data objects. Exceptions to this rule are cases where the meaning of a name is absolutely clear, for example, the declaration of a helper variable:
</p>
<dl><dd>
<span class="qtext">DATA i TYPE i.</span>
</dd></dl>
<p>
However, it should never be the case that a data object has the name of a data type that is not the type of the object:
</p>
<dl><dd>
<span class="qtext">DATA i&nbsp;&nbsp;&nbsp;&nbsp; TYPE f. <br>DATA tadir TYPE trdir.</span>
</dd></dl>
<p>
This is both confusing and dangerous!
</p>
<p><span class="h4">
Obscuring of More Global Declarations
</span></p>
<p>
The names in local contexts obscure declarations with the same name in contexts that are more global.
In a method, for example, a data type declared with <span class="qtext">TYPES</span> obscures an identically
named data type of the class. This data type then obscures the identically named data type of the program, which in turn obscures an identically named data type from ABAP Dictionary.
</p>
<p>
Developers must ensure that a more global object (that should be used in the current context) is not
obscured. Conversely, a global object must not be accidentally used instead of a local object. The reader
of the source code should always know what a name refers to. This means that, when names are given, local names should not obscure any names that are more global.
</p>
<p>
Following the <a href="javascript:call_link('abenkiss_principle_guidl.html')" class="lnkpurple" title="Guideline">KISS principle</a>,
it is recommended that local names are different from global names, because they do not follow their
conventions. This mainly refers to the names in global declarations of the current program or in the
repository. For example, a local class should never start with the <span class="qtext">cl_</span> prefix,
a local interface should never start with <span class="qtext">if_</span> prefix, and a local data object should never start with the <span class="qtext">g_</span> prefix.
</p>
<ul class="disc">
<li><span class="bold">Within methods</span></li>
</ul>
<dl><dd>
In a method (in new function modules and subroutines, there should be
<a href="javascript:call_link('abenfunct_module_subroutine_guidl.html')" class="lnkpurple" title="Guideline">no local declarations</a>),
there is the danger that local names (including method parameters) can be confused with more global
names. Declarations within the implementation can also be confused with method parameters. It should also be noted that methods in the same class always obscure any built-in functions with the same name.
</dd></dl>
<dl><dd>
To prevent local data objects in a method from being confused with components of their own class, you
can explicitly address class components using the name of the class and the class component selector (=>), or using the object reference variable <span class="qtext">me</span> and the instance component selector (->) .
</dd></dl>
<dl><dd>
If there is a danger that identically named built-in functions can be confused, the functional methods
of the same class should be addressed only by using one of the selectors when using functional method
calls. However, excessive use of selectors can make the source code difficult to read. Therefore, each
case should be assessed separately. This danger of confusion is only relevant for short method names,
however. For methods with names consisting of multiple words or names that start with the prefixes <span class="qtext">
set_</span>, <span class="qtext">get_</span>, or <span class="qtext">is_</span>, there is usually no risk of confusion. Methods should always have a
<a href="javascript:call_link('abenproc_volume_guidl.html')" class="lnkpurple" title="Guideline">manageable size</a>, and all
declarations are therefore always visible for the reader. Therefore, this simple rule should be sufficient to make the method easy to read.
</dd></dl>
<dl><dd>
If the declaration of the method&#x2019;s parameter interface is not visible in the method implementation
(as in local classes), it is useful to make an additional distinction between local data and the method
parameters. It has become customary to use the prefixes mentioned earlier to achieve this. An alternative
prefix component <span class="qtext">l</span> could also be considered here for local data, but it ultimately represents redundant information.
</dd></dl>
<ul class="disc">
<li><span class="bold">Within classes</span></li>
</ul>
<dl><dd>
If you use class components, you can always avoid confusion by addressing the class components using the name of the class and the class component selector
(<span class="qtext">=></span>) or an object reference variable and the instance component selector
(<span class="qtext">-></span>). The implementation of a corresponding naming convention would lead to redundant information, which would not improve readability and would be contradictory to the basic
<a href="javascript:call_link('abenkiss_principle_guidl.html')" class="lnkpurple" title="Guideline">KISS principle</a>. This
applies in particular to the methods of the class. Although these methods obscure any identically named
built-in functions, it would be very unusual to implement a prefix that indicates a method as a method of a class. Instead, methods should not be given the names of built-in functions.
</dd></dl>
<ul class="disc">
<li><span class="bold">In programs (general)</span></li>
</ul>
<dl><dd>
In the global declaration part of a program, you can create local classes and interfaces, as well as global data types and data objects.
</dd></dl>
<ul class="circlem2">
<li>The names of local classes and interfaces do not follow the naming conventions for global classes
and interfaces. In other words, they cannot start with <span class="qtext">cl_</span> or <span class="qtext">if_</span>,
to ensure that no global declarations are obscured. With respect to local data, you can consider the
naming convention <span class="qtext">lcl_</span> or <span class="qtext">lif_</span>, but this would
be redundant and not necessarily required, because a class/interface without a prefix is always known
as a local class/local interface. The use of <span class="qtext">lif_</span> may be useful for distinguishing a local interface from a local class.</li>
</ul>
<ul class="circlem2">
<li>Data types should no longer occur in the <a href="javascript:call_link('abendeclaration_variables_guidl.html')" class="lnkpurple" title="Guideline">
global declaration part</a> of a program. Global data objects are only required for communication between ABAP and dynpro if
<a href="javascript:call_link('abenencap_class_interf_guidl.html')" class="lnkpurple" title="Guideline">classic dynpros</a> are
used. Since these objects cannot names cannot be prefixed with a program name, as with class attributes
(absolute names are only possible for data types and only in dynamic specifications), you must use the
<span class="qtext">g_</span> prefix for global data objects, to prevent confusion with local data objects
or class attributes in method implementations. Global data objects can only exist in executable programs,
module pools, and function groups. Global classes and interfaces cannot contain any global data objects.
Therefore, a <span class="qtext">g_</span> prefix for class components or interface components is definitely the wrong choice.</li>
</ul>
<p><span class="h4">
Note
</span></p>
<p>
Naming conventions are frequently established for names within the source code that define specifications
for naming, including potential prefixes and suffixes. These specifications often get bogged down in
excessive formal strictness. Names created this way contain redundant information, are difficult to
maintain and often do not achieve the main aim of readability and self-documenting sources. Therefore,
we limited our discussion to the naming-related aspects that we consider  essential and universal. Further specifications are only useful at the level of development groups/organizations.
</p>
<p>
If prefixes and/or suffixes are used, it is common practice to store the technical attributes of the
described object in these prefixes/suffixes. Apart from the fact that we do not consider it necessary
to specify technical information in names, there are so many technical attributes of an object in ABAP
that they cannot be mapped using simple rules for short prefixes/suffixes. Or combinations of different technical additions often cannot be interpreted uniquely. Some examples:
</p>
<ul class="disc">
<li>With respect to the <span class="italic">data type</span> of a data object, there are naming conventions
where "v" and "c" as prefixes stand for "variable" or "constant" elementary data objects. Similarly,
"s" and "t" as prefixes stand for "structures" and internal "tables". The type attribute "elementary"
is wrongly equated with "variable" or "constant". If the attributes "static variable" and "sorted table"
are also supposed to be expressed using "s", this is very likely to cause mistakes with name assignments. This makes it much harder to achieve the goal of readable, self-documenting source codes.</li>
</ul>
<ul class="disc">
<li>With respect to the <span class="italic">validity area</span> or the <span class="italic">context</span>
of a data object, the naming conventions often stipulate the prefixes <span class="qtext">g_</span>
and <span class="qtext">l_</span> for the names of global and local data objects. We identified <span class="qtext">
g_</span> for global data objects as the only convention that is actually required for program-internal
names. However, the simultaneously labeling of all non-global objects with the prefix <span class="qtext">l_</span>
for the local validity area is almost never necessary. <span class="qtext">l_</span> should only be
used if a local name is to be the same as a more global name and the corresponding lack of obscuring
component selectors would produce unreadable source code. The latter case only occurs for long class
names in front of <span class="qtext">=></span>. If <span class="qtext">me-></span> is used in front
of the names of instance attributes, the method does not become any less unreadable than when an <span class="qtext">l_</span> is placed in front of the name of a local data object.</li>
</ul>
<dl><dd>
It would actually be completely misleading to label static attributes of classes as global, using the
prefix <span class="qtext">g_</span>. These attributes are only valid within the class and have completely
different semantics than global data objects. The use of these attributes does not indicate a design weakness as it is generally the case for global data objects today.
</dd></dl>
<ul class="disc">
<li>With respect to the <span class="italic">method parameters</span>, we identified the prefixes <span class="qtext">
i_</span>, <span class="qtext">e_</span>, <span class="qtext">c_</span>, and <span class="qtext">r_</span>
for importing, exporting, changing, and returning parameters as possible characteristics for distinguishing
from data objects declared in the method. Apart from this, no further technical information needs to
be expressed with additional prefixes. With method parameters in particular, technical information in
prefixes tends to cause confusion rather than improve readability. For example, a prefix <span class="qtext">is_</span>
for "importing structure" would conflict with the prefix <span class="qtext">is_</span> for "truth values",
and a prefix <span class="qtext">it_</span> for "importing table" could easily be understood as a general
abbreviation of "internal table". If the role the parameter plays cannot be known from the descriptive
name of a parameter and the procedure name, the names assigned are completely wrong and/or the procedure
does not fulfill any clearly defined tasks. This type of conceptual weakness cannot be fixed (even with technical prefixes).</li>
</ul>
<p>
In summary, we recommend that you should use name additions cautiously, particularly additions with
technical information. Of course, every organization is free to use these conventions, which can supplement
our basic rules. In the ABAP environment - with its high versatility of types, many contexts, the distinction
between pass by reference and pass by value - it is probably not an easy task to create a complete,
self-contained, consistent, technically correct, and &#x2014; above all &#x2014; easy-to-understand
set of rules for prefixes and suffixes. The known results are just pure conventions that are usually incomplete and are not always applicable.
</p>
<p><span class="h4">
Bad Example
</span></p>
<p>
The example shown below demonstrates how to obscure names in different contexts. The fact that no descriptive names were used for the data objects (for the sake of simplicity) can be disregarded here.
</p>
<dl><dd>
<span class="qtext">DATA a1 TYPE string VALUE `a1 global`. <br>DATA a2 TYPE string VALUE `a2 global`. <br>
DATA a3 TYPE string VALUE `a3 global`. <br>DATA a4 TYPE string VALUE `a4 global`. <br>DATA a5 TYPE string VALUE `a5 global`.</span>
</dd></dl>
<dl><dd>
<span class="qtext">CLASS demo DEFINITION. <br>&nbsp;&nbsp;PUBLIC SECTION. <br>&nbsp;&nbsp;&nbsp;&nbsp;METHODS main <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMPORTING a1 TYPE string DEFAULT 'a1 imported' <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURNING value(a6) TYPE string. <br>
&nbsp;&nbsp;&nbsp;&nbsp;CLASS-DATA a1&nbsp;&nbsp;TYPE string VALUE `a1 class`. <br>&nbsp;&nbsp;&nbsp;&nbsp;CLASS-DATA a2&nbsp;&nbsp;TYPE string VALUE `a2 class`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE string VALUE `a3 class`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE string VALUE `a4 class`. <br>ENDCLASS.</span>
</dd></dl>
<dl><dd>
<span class="qtext">CLASS demo IMPLEMENTATION. <br>&nbsp;&nbsp;METHOD main. <br>&nbsp;&nbsp;&nbsp;&nbsp;DATA a3 TYPE string VALUE `a3 local`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a4 TYPE string VALUE `a4 local`. <br>&nbsp;&nbsp;&nbsp;&nbsp;CONCATENATE a1 demo=>a2 me->a3 a4 a5 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INTO a6 SEPARATED BY `, `. <br>&nbsp;&nbsp;ENDMETHOD. <br>ENDCLASS.</span>
</dd></dl>
<p>
If you just consider the implementation of the <span class="qtext">main</span> method in the <span class="qtext">CONCATENATE</span>
statement, it is clearly evident only for the <span class="qtext">demo=>a2</span> and <span class="qtext">me->a3</span>
operands that they are attributes of the class and that a4 is a local data object of the method. It
is only possible in the general overview to see that <span class="qtext">a1</span> describes an importing
parameter, <span class="qtext">a5</span> describes a global data object of the program, and a6 describes
a returning parameter. The global data objects a1 to a4 cannot be addressed in the method because they are obscured by local data objects or attributes of the class.
</p>
<p><span class="h4">
Good Example
</span></p>
<p>
Unlike the source code above, the following source code includes the previously discussed prefixes,
to prevent obscuring and to distinguish method parameters from local data objects. Again, descriptive names were not used here to focus on aspects that are essential for this example.
</p>
<dl><dd>
<span class="qtext">DATA g_a1 TYPE string VALUE `g_a1 global`. <br>DATA g_a2 TYPE string VALUE `g_a2 global`. <br>
DATA g_a3 TYPE string VALUE `g_a3 global`. <br>DATA g_a4 TYPE string VALUE `g_a4 global`. <br>DATA g_a5 TYPE string VALUE `g_a5 global`.</span>
</dd></dl>
<dl><dd>
<span class="qtext">CLASS demo DEFINITION. <br>&nbsp;&nbsp;PUBLIC SECTION. <br>&nbsp;&nbsp;&nbsp;&nbsp;METHODS main <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMPORTING i_a1 TYPE string DEFAULT 'i_a1 imported' <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURNING value(r_a6) TYPE string. <br>
&nbsp;&nbsp;&nbsp;&nbsp;CLASS-DATA a1&nbsp;&nbsp;TYPE string VALUE `a1 class`. <br>&nbsp;&nbsp;&nbsp;&nbsp;CLASS-DATA a2&nbsp;&nbsp;TYPE string VALUE `a2 class`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE string VALUE `a3 class`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE string VALUE `a4 class`. <br>ENDCLASS.</span>
</dd></dl>
<dl><dd>
<span class="qtext">CLASS demo IMPLEMENTATION. <br>&nbsp;&nbsp;METHOD main. <br>&nbsp;&nbsp;&nbsp;&nbsp;DATA a3 TYPE string VALUE `a3 local`. <br>
&nbsp;&nbsp;&nbsp;&nbsp;DATA a4 TYPE string VALUE `a4 local`. <br>&nbsp;&nbsp;&nbsp;&nbsp;CONCATENATE i_a1 demo=>a2 me->a3 a4 g_a5 <br>
&nbsp;&nbsp;&nbsp;&nbsp; INTO r_a6 SEPARATED BY `, `. <br>&nbsp;&nbsp;ENDMETHOD. <br>ENDCLASS.</span>
</dd></dl>
<p>
All operands are now clearly known in the <span class="qtext">CONCATENATE</span> statement. A prefix (<span class="qtext">l_</span>) can be implemented for the local names, but this is unnecessary for two reasons:
</p>
<ul class="disc">
<li>The declaration is defined near the place of usage and is always visible to the reader.</li>
</ul>
<ul class="disc">
<li>If you consistently use the selectors <span class="qtext">-></span> and <span class="qtext">=></span>
to address the attributes of a class, all names without a prefix and with no specified class or a reference variable are known as local data objects.</li>
</ul>
<p>
By applying the minimal naming convention used here, you can address all data objects that are declared
in the displayed source code section in the method. Of course, the declaration of the global data objects is only implemented to demonstrate obscuring and how to prevent it. Global data objects should
<a href="javascript:call_link('abendeclaration_variables_guidl.html')" class="lnkpurple" title="Guideline">no longer be used</a> in programs that do not work with classic dynpros.
</p>
<br>
<br>
<br>
<br>
</DIV>
<fieldset style="opacity:0">
<input id="url" type="text" />
</fieldset>
</BODY>

<!-- Mirrored from help.sap.com/doc/abapdocu_754_index_htm/7.54/en-US/abenprog_intern_names_guidl.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Feb 2024 14:53:05 GMT -->
</html>
